{"meta":{"title":"hechao的diary","subtitle":"","description":"","author":"hechao","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"iOS静态库打包问题","slug":"iOS静态库打包问题","date":"2022-04-20T08:44:34.831Z","updated":"2022-04-20T09:14:33.843Z","comments":true,"path":"2022/04/20/iOS静态库打包问题/","link":"","permalink":"http://yoursite.com/2022/04/20/iOS%E9%9D%99%E6%80%81%E5%BA%93%E6%89%93%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、iOS静态库打包.a文件1、build生成Debug-iphoneos和Debug-iphonesimulator lib.a文件2、合成模拟器和真机.a文件 123lipo -create iphoneos.a iphonesimulator -output new.aExmaple:lipo -create &#x2F;Users&#x2F;hechao&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;SGECNetService-gzmdcobzfojmfaascggxhupdtpym&#x2F;Build&#x2F;Products&#x2F;Debug-iphoneos&#x2F;libSGECNetService.a &#x2F;Users&#x2F;hechao&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;SGECNetService-gzmdcobzfojmfaascggxhupdtpym&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;libSGECNetService.a -output &#x2F;Users&#x2F;hechao&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;SGECNetService-gzmdcobzfojmfaascggxhupdtpym&#x2F;Build&#x2F;Products&#x2F;libSGECNetService.a 3、验证合包是否成功 1lipo -info libSGECNetService.a 输出： 1Architectures in the fat file: &#x2F;Users&#x2F;hechao&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;SGECNetService-gzmdcobzfojmfaascggxhupdtpym&#x2F;Build&#x2F;Products&#x2F;libSGECNetService.a are: x86_64 arm64 4、导入工程引入.h文件 二、解决库冲突打包好的.a文件有时包含项目中已引用的第三方sdk，这是会报duplicate symbol for architecture arm64(x86_x64) 这是需要移除冲突的.o文件1、一般静态库都是’胖(fat)’库, 里面包含多个架构，, 这个命令一般会输出 “xxx.a are: armv7 x86_64 arm64” 1lipo -info lib.a 2、按照架构分解.a，我们需要把不同架构的.a文件分解出来 123lipo -thin arm64 .&#x2F;lib.a -output .&#x2F;arm64.alipo -thin armv7 .&#x2F;lib.a -output .&#x2F;armv7.alipo -thin x86_64 .&#x2F;lib.a -output .&#x2F;x86_64.a 3、查看.a文件包含的.o文件 1ar -v -t .&#x2F;arm64.a 4、删除.a文件中包含的.o文件根据实际情况，删除包含的.o文件，每个架构都要删除 123ar -v -d arm64.a AFURLSessionManager.o ar -v -d armv7.a AFURLSessionManager.o ar -v -d x86_64.a AFURLSessionManager.o 5、最后合并所有架构的.a文件成一个新的.a胖包 1lipo -create .&#x2F;arm64.a .&#x2F;armv7.a .&#x2F;x86_64.a -output .&#x2F;lib.a Finish！🐯🐯🐯🐯🐯🐯","categories":[],"tags":[]},{"title":"wkwebview富文本高度","slug":"wkwebview富文本高度","date":"2021-02-08T05:45:20.160Z","updated":"2021-06-19T10:18:22.892Z","comments":true,"path":"2021/02/08/wkwebview富文本高度/","link":"","permalink":"http://yoursite.com/2021/02/08/wkwebview%E5%AF%8C%E6%96%87%E6%9C%AC%E9%AB%98%E5%BA%A6/","excerpt":"","text":"获取到返回的富文本信息，拼接成html 12NSString *str &#x3D; [NSString stringWithFormat:@&quot;&lt;html&gt;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&lt;meta name&#x3D;\\&quot;viewport\\&quot;content&#x3D;\\&quot;width&#x3D;device-width, initial-scale&#x3D;1.0, minimum-scale&#x3D;1.0, maximum-scale&#x3D;1.0, user-scalable&#x3D;no\\&quot;&gt;&lt;title&gt;&lt;&#x2F;title&gt;&lt;head&gt;&lt;script type&#x3D;\\&quot;text&#x2F;javascript\\&quot;&gt;window.onload &#x3D; function() &#123;window.location.href &#x3D; \\&quot;ready:&#x2F;&#x2F;\\&quot; + document.body.scrollHeight;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;%@&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;,self.model.content];[self.webView loadHTMLString:str baseURL:nil]; 调用wkwebview 的代理方法 12345678910111213141516171819202122232425- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; if (navigationAction.navigationType &#x3D;&#x3D; WKNavigationTypeOther) &#123; if ([[[navigationAction.request URL] scheme] isEqualToString:@&quot;ready&quot;]) &#123; float contentHeight &#x3D; [[[navigationAction.request URL] host] floatValue]; CGRect webFrame &#x3D; self.webView.frame; webFrame.size.height &#x3D; contentHeight; webView.frame &#x3D; webFrame; NSLog(@&quot;onload &#x3D; %f&quot;,contentHeight); self.containerScrollView.contentSize &#x3D; CGSizeMake(self.view.width, self.webView.top + contentHeight); CGFloat webViewHeight &#x3D; (contentHeight &lt; self.view.height) ? contentHeight :self.view.height; self.webView.height &#x3D; webViewHeight &lt;&#x3D; 0.1 ?0.1 :webViewHeight; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; &#125; decisionHandler(WKNavigationActionPolicyAllow); &#125; 获取到html高度","categories":[],"tags":[]},{"title":"uilabel富文本","slug":"uilabel富文本","date":"2021-02-08T05:45:20.160Z","updated":"2021-06-19T10:23:33.600Z","comments":true,"path":"2021/02/08/uilabel富文本/","link":"","permalink":"http://yoursite.com/2021/02/08/uilabel%E5%AF%8C%E6%96%87%E6%9C%AC/","excerpt":"","text":"返回的HTML文本 12345NSString *htmlStr &#x3D; [NSString stringWithFormat:@&quot;&lt;head&gt;&lt;style&gt;img&#123;width:%f !important;height:auto&#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;%@&quot;,SCREEN_WIDTH - WW(36),_model.content]; &#x2F;&#x2F;富文本，两种都可以NSDictionary *options &#x3D; @&#123; NSDocumentTypeDocumentAttribute : NSHTMLTextDocumentType, NSCharacterEncodingDocumentAttribute :@(NSUTF8StringEncoding) &#125;;NSData *data &#x3D; [htmlStr dataUsingEncoding:NSUTF8StringEncoding]; 或者 12NSDictionary *option &#x3D; @&#123;NSDocumentTypeDocumentAttribute : NSHTMLTextDocumentType&#125;;NSData *data &#x3D; [htmlStr dataUsingEncoding:NSUnicodeStringEncoding]; 设置富文本 1234567NSMutableAttributedString *attStr &#x3D; [[NSMutableAttributedString alloc] initWithData:data options:options documentAttributes:nil error:nil];&#x2F;&#x2F;设置段落格式NSMutableParagraphStyle *para &#x3D; [[NSMutableParagraphStyle alloc] init];para.lineSpacing &#x3D; 7;para.paragraphSpacing &#x3D; 10;[attStr addAttribute:NSParagraphStyleAttributeName value:para range:NSMakeRange(0, attStr.length)];self.richTextLb.attributedText &#x3D; attStr; 可以直接使用html样式 123456789NSString *str &#x3D; @&quot;&lt;font color&#x3D;\\&quot;#6c6c6c\\&quot;&gt;满20减5 满40减15，还剩&lt;font color&#x3D;\\&quot;#ff9147\\&quot;&gt;113天&quot;;UILabel *label &#x3D; [[UILabel alloc] initWithFrame:CGRectMake(30, 50, 300, 50)];NSAttributedString *attrStr &#x3D; [[NSAttributedString alloc] initWithData:[str dataUsingEncoding:NSUnicodeStringEncoding] options:@&#123;NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType&#125; documentAttributes:nil error:nil];label.attributedText &#x3D; attrStr;&#x2F;&#x2F;如果想要改变文字的字体,请在设置attributedText之后设置label.font &#x3D; [UIFont systemFontOfSize:20];[self.view addSubview:label];","categories":[],"tags":[]},{"title":"关于masnory布局","slug":"关于masonry布局","date":"2021-01-13T03:47:23.489Z","updated":"2021-06-19T10:12:03.323Z","comments":true,"path":"2021/01/13/关于masonry布局/","link":"","permalink":"http://yoursite.com/2021/01/13/%E5%85%B3%E4%BA%8Emasonry%E5%B8%83%E5%B1%80/","excerpt":"","text":"mas_remakeConstraintsmas_updateConstraintsmas_makeConstraintsUIViewAlertForUnsatisfiableConstraints //显示多列按钮 123456NSArray *viewArray &#x3D; @[buyBtn, saleBtn, remindBtn];[viewArray mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedItemLength:70 leadSpacing:10 tailSpacing:5];[viewArray makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.equalTo(bottomView); make.height.equalTo(35);&#125;]; masonry 动画 [self.view addSubview:self.filterView]; [self.filterView mas_makeConstraints:^(MASConstraintMaker *make) { make.left.mas_equalTo(SCREEN_WIDTH); make.top.mas_equalTo(self.operatView.mas_bottom); make.width.mas_equalTo(SCREEN_WIDTH); make.bottom.mas_equalTo(0); }]; self.operatView.operatSilterBlock = ^{ [UIView animateWithDuration:0.3 animations:^{ weakSelf.filterView.hidden = NO; [weakSelf.filterView mas_updateConstraints:^(MASConstraintMaker *make) { make.left.mas_equalTo(0); }]; // 需要调用这个方法 [weakSelf.view layoutIfNeeded]; }]; };","categories":[],"tags":[]},{"title":"block的使用","slug":"block的使用","date":"2020-07-22T08:11:20.000Z","updated":"2021-06-17T15:21:19.304Z","comments":true,"path":"2020/07/22/block的使用/","link":"","permalink":"http://yoursite.com/2020/07/22/block%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"返回类型 名称 参数类型 123456789101112131415161718void (^loggerBlock)(void) &#x3D; ^void(void) &#123; NSLog(@&quot;hello&quot;);&#125;;loggerBlock();void (^loggerBlockWithString)(NSString *) &#x3D; ^void(NSString *str) &#123; NSLog(@&quot;hello %@！&quot;,str);&#125;;NSString *str &#x3D; @&quot;小**&quot;;loggerBlockWithString(str);NSString *str1 &#x3D; @&quot;hello 小**&quot;;self.propertyBlock &#x3D; ^(NSString *str) &#123; NSLog(@&quot;%@&quot;,str);&#125;;self.propertyBlock(str1); // 后台执行 123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; &#125;); // 主线程 123dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;); // 执行一次 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; &#125;); // 延迟 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; &#125;); // 后台两个线程并行执行，等两个都结束之后，执行结果 12345678910dispatch_group_t group &#x3D; dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;这是111111111&quot;);&#125;);dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;这是222222222&quot;);&#125;);dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;1和2都完成了&quot;);&#125;); // 修改block之外的变量 1234567__block int a &#x3D; 10;void(^foo)(void) &#x3D; ^&#123; a++;&#125;;NSLog(@&quot;a的值为：%d&quot;,a);foo();NSLog(@&quot;a的值为：%d&quot;,a); 使用 block 的另一个用处是可以让程序在后台较长久的运行在以前，当 app 被按 home 键退出后，app 仅有最多 5 秒钟的时候做一些保存或清理资源的工作。但是应用可以调用 UIApplication 的beginBackgroundTaskWithExpirationHandler方法，让 app 最多有 10 分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作 1234567891011121314151617181920212223242526- (void)sceneDidEnterBackground:(UIScene *)scene &#123; &#x2F;&#x2F; Called as the scene transitions from the foreground to the background. &#x2F;&#x2F; Use this method to save data, release shared resources, and store enough scene-specific state information &#x2F;&#x2F; to restore the scene back to its current state. [self beingBackgroundUpdateTask]; &#x2F;&#x2F; 在这里加上你需要长久运行的代码 for (int i &#x3D; 0; i &lt; 100; i++) &#123; NSLog(@&quot;%d&quot;,i); &#125; sleep(2); NSLog(@&quot;222222222&quot;); [self endBackgroundUpdateTask];&#125;- (void)beingBackgroundUpdateTask &#123; self.backgroundUpdateTask &#x3D; [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123; &#125;];&#125;- (void)endBackgroundUpdateTask &#123; [[UIApplication sharedApplication] endBackgroundTask:self.backgroundUpdateTask]; self.backgroundUpdateTask &#x3D; UIBackgroundTaskInvalid;&#125;","categories":[],"tags":[]},{"title":"离屏渲染","slug":"离屏渲染","date":"2020-07-21T08:27:55.000Z","updated":"2020-07-21T08:28:43.448Z","comments":true,"path":"2020/07/21/离屏渲染/","link":"","permalink":"http://yoursite.com/2020/07/21/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/","excerpt":"","text":"下面几种情况会触发离屏渲染：1、使用了mask的layer(layer.mask)2、需要进行裁剪的layer(layer.maskToBounds / view.clipsToBounds)3、设置了组透明度为yes，并且透明度不为1的layer(layer.allowGroupOpacity / layer.opacity)4、添加了投影的layer(layer.shadow)5、采用了光栅化的layer(layer.shouldRasterize)6、绘制了文字的layer(UILabel,CATextLayer,Core Text等)","categories":[],"tags":[]}],"categories":[],"tags":[]}