{"meta":{"title":"hechao的diary","subtitle":"","description":"","author":"hechao","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"block的使用","slug":"block的使用","date":"2020-07-22T08:11:20.000Z","updated":"2020-07-22T08:23:37.457Z","comments":true,"path":"2020/07/22/block的使用/","link":"","permalink":"http://yoursite.com/2020/07/22/block%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"返回类型 名称 参数类型 123456789101112131415161718void (^loggerBlock)(void) &#x3D; ^void(void) &#123; NSLog(@&quot;hello&quot;);&#125;;loggerBlock();void (^loggerBlockWithString)(NSString *) &#x3D; ^void(NSString *str) &#123; NSLog(@&quot;hello %@！&quot;,str);&#125;;NSString *str &#x3D; @&quot;小钱&quot;;loggerBlockWithString(str);NSString *str1 &#x3D; @&quot;hello 小钱&quot;;self.propertyBlock &#x3D; ^(NSString *str) &#123; NSLog(@&quot;%@&quot;,str);&#125;;self.propertyBlock(str1); // 后台执行 123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; &#125;); // 主线程 123dispatch_async(dispatch_get_main_queue(), ^&#123; &#125;); // 执行一次 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; &#125;); // 延迟 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; &#125;); // 后台两个线程并行执行，等两个都结束之后，执行结果 12345678910dispatch_group_t group &#x3D; dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;这是111111111&quot;);&#125;);dispatch_group_async(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;这是222222222&quot;);&#125;);dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^&#123; NSLog(@&quot;1和2都完成了&quot;);&#125;); // 修改block之外的变量 1234567__block int a &#x3D; 10;void(^foo)(void) &#x3D; ^&#123; a++;&#125;;NSLog(@&quot;a的值为：%d&quot;,a);foo();NSLog(@&quot;a的值为：%d&quot;,a); 使用 block 的另一个用处是可以让程序在后台较长久的运行在以前，当 app 被按 home 键退出后，app 仅有最多 5 秒钟的时候做一些保存或清理资源的工作。但是应用可以调用 UIApplication 的beginBackgroundTaskWithExpirationHandler方法，让 app 最多有 10 分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作 1234567891011121314151617181920212223242526- (void)sceneDidEnterBackground:(UIScene *)scene &#123; &#x2F;&#x2F; Called as the scene transitions from the foreground to the background. &#x2F;&#x2F; Use this method to save data, release shared resources, and store enough scene-specific state information &#x2F;&#x2F; to restore the scene back to its current state. [self beingBackgroundUpdateTask]; &#x2F;&#x2F; 在这里加上你需要长久运行的代码 for (int i &#x3D; 0; i &lt; 100; i++) &#123; NSLog(@&quot;%d&quot;,i); &#125; sleep(2); NSLog(@&quot;222222222&quot;); [self endBackgroundUpdateTask];&#125;- (void)beingBackgroundUpdateTask &#123; self.backgroundUpdateTask &#x3D; [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123; &#125;];&#125;- (void)endBackgroundUpdateTask &#123; [[UIApplication sharedApplication] endBackgroundTask:self.backgroundUpdateTask]; self.backgroundUpdateTask &#x3D; UIBackgroundTaskInvalid;&#125;","categories":[],"tags":[]},{"title":"离屏渲染","slug":"离屏渲染","date":"2020-07-21T08:27:55.000Z","updated":"2020-07-21T08:28:43.448Z","comments":true,"path":"2020/07/21/离屏渲染/","link":"","permalink":"http://yoursite.com/2020/07/21/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/","excerpt":"","text":"下面几种情况会触发离屏渲染：1、使用了mask的layer(layer.mask)2、需要进行裁剪的layer(layer.maskToBounds / view.clipsToBounds)3、设置了组透明度为yes，并且透明度不为1的layer(layer.allowGroupOpacity / layer.opacity)4、添加了投影的layer(layer.shadow)5、采用了光栅化的layer(layer.shouldRasterize)6、绘制了文字的layer(UILabel,CATextLayer,Core Text等)","categories":[],"tags":[]},{"title":"今天天气不错","slug":"今天天气不错","date":"2020-07-21T06:24:55.000Z","updated":"2020-07-21T07:00:04.646Z","comments":true,"path":"2020/07/21/今天天气不错/","link":"","permalink":"http://yoursite.com/2020/07/21/%E4%BB%8A%E5%A4%A9%E5%A4%A9%E6%B0%94%E4%B8%8D%E9%94%99/","excerpt":"","text":"小钱，今天天气不错！","categories":[],"tags":[]}],"categories":[],"tags":[]}